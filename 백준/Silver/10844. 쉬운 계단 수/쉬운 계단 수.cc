#include <iostream>
#define MAX 101
#define M 1000000000
using namespace std;
//      dp[1](1)        dp[2](2)              dp[3](3)                       dp[4](8)
// 0 :    0           10 
// 1 :    1     |   10, 12    |    101, 121, 123         |    1010, 1012, 1210, 1212, 1232, 1234
// 2 :    2     |   21, 23 	  |    210, 212, 232, 234    |    2101, 2121, 2123, 2321, 2323, 2343, 2345
// 3 :    3		|   32, 34	  |    321, 323, 343, 345    |    3210, 3212, 3232, 3234, 3432, 3434, 3454, 3456
// 4 :    4		|   43, 45	  |    432, 434, 454, 456    |    4321, 4323, 4343, 4344, 4543, 4545, 4565, 4567
// 5 :    5		|   54, 56	  |    543, 545, 565, 567    |    5432, 5434, 5454, 5456, 5654, 5656, 5676, 5678
// 6 :    6		|   65, 67    |    654, 656, 676, 678    |    6543, 6545, 6565, 6567, 6765, 6767, 6787, 6789
// 7 :    7		|   76, 78	  |    765, 767, 787, 789    |    7654, 7656, 7676, 7678, 7878, 7879, 7898
// 8 :    8		|   87, 89	  |    876, 878, 898	     |    8765, 8767, 8787, 8789, 8987, 8989
// 9 :    9		|   98		  |    987  989			     |    9876, 9878, 9898

long long dp[MAX][MAX],ans;
int n;

int main()
{
	ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	cin >> n;
	// dp[길이][마지막 수]
	// 길이 1은 무조건 1
	for (int i = 1; i <= 9; i++)dp[1][i] = 1;
	dp[1][0] = 0;


	// i : 길이
	for (int i = 2; i <= n; i++)
	{
		// j : 마지막 자리 수
		for (int j = 0; j <= 9; j++)
		{
			// 0의 개수는 이전 길이의 1의 개수
			if (j == 0)dp[i][j] = dp[i - 1][1] % M;
			// 9의 개수는 이전 길이의 8의 개수
			else if (j == 9) dp[i][j] = dp[i - 1][8] % M;
			// 마지막 자리수를 가지는 경우는 그 수의 양 옆
			else dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j + 1]) % M;
		}
	}

	

	for (int i = 0; i <= 9; i++) ans += dp[n][i];

	cout << ans % M;

}